#!/usr/bin/python3

# Copyright 2018-2019 Leland Lucius
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http:#www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import glob
import json
import os
import sys

from lxml import etree
from selenium import webdriver

# Should be within the "z/VM: Systems Management Application Programming" guide
URL = "https://www.ibm.com/support/knowledgecenter/en/SSB27U_7.1.0/com.ibm.zvm.v710.dmse6/sok.htm"

# Refresh saved copies of pages if asked
if len(sys.argv) > 1 and sys.argv[1] == "refresh":

    # Use the (deprecated) PhantomJS driver for now...it's the easiest by far
    driver = webdriver.PhantomJS()

    # Get the list of functions
    driver.get(URL)

    # Extract the functions and links
    fns = {}
    items = driver.find_elements_by_xpath("//li[@title='Socket Application Programming Interfaces']/ul[@role='group']/li[contains(@class, 'kc-toc-item')]//a")
    for a in items:
        fns[a.get_attribute("aria-label").strip()] = a.get_attribute("href").strip()

    # Get the page and save the content frame
    for fn, href in fns.items():
        print(f"Getting {fn}")
        driver.get(href)
        driver.switch_to.frame("kcframe")
        open(f"content/{fn}", "w").write(driver.page_source)

# Must use the HTML parser
parser = etree.HTMLParser()

db = {}

# Process the saved pages
for path in glob.glob("content/*"):

    # Load the page
    root = etree.parse(open(path), parser)

    # Locate the "Return and Reason Code" header
    e = root.xpath("//section/h2[text()='Return and Reason Codes']")

    # Nagivate to its parent
    p = e[0].getparent()

    # Extract the function name from the path
    fn = os.path.basename(path).split(".")[0]

    print(f"Processing {fn}")

    # Locate all rows within the section
    rows = p.xpath(".//tr")

    # Prepare
    rc = None
    rs = None
    et = None
    db[fn] = {}

    # process each row
    for row in rows:
        # Extracts assembled text fragments from node
        def gettext(node):
            t = ""
            tails = []

            # Scan node and all children for text
            for e in node.iter():
                if e.text is None and e.tail is None:
                    pass
                elif e.text is None and e.tail is not None:
                    tails.append(e.tail)
                elif e.text is not None and e.tail is None:
                    # Quote fragment if it falls at the start of the text or
                    # accumulated text ends with whitespace
                    if not t or (t and t[-1] in [" ", "\n"]):
                        t += f"'{e.text}'"
                    else:
                        t += e.text

                    if len(tails) > 1:
                        t += tails.pop()
                elif e.text is not None and e.tail is not None:
                    # Quote fragment if the accumulated text ends with whitespace
                    if t and t[-1] in [" ", "\n"]:
                        t += f"'{e.text}'"
                    else:
                        t += e.text

                    tails.append(e.tail)

            # Append any remaining fragments to accumulated text
            if len(tails) > 0:
                t += "".join(tails)

            t = " ".join(t.replace("\n", " ").replace('"', "'").split()).strip(".")

            # Get rid of quotes if entire text is quoted
            if t and t[0] == "'" and t[-1] == "'":
                t = t.strip("'")

            return t

        # Locate all the columns
        cols = row.xpath("./td")
        if len(cols) == 0:
            continue

        # Get the return code or reuse previous is this column is blank
        tc = gettext(cols[0])
        if tc != "":
            rc = tc

        # Get the reason code or reuse previous is this column is blank
        tc = gettext(cols[2])
        if tc != "":
            rs = f"_{tc}" if tc.isdigit() else ""

        # Get the message text
        et = gettext(cols[4])

        # Store it in the DB
        db[fn][f"{rc}{rs}"] = et

s = json.dumps(db, indent=4)
print(s)
with open("pysmapi/messages.py", "w") as f:
    f.write(f"# Automatically generated by {os.path.basename(sys.modules[__name__].__file__)}\n\n")
    f.write(f"msgdb = \\\n")
    f.write(s)

